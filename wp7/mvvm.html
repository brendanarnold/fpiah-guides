<!DOCTYPE html>
<html>
  <head>
    <title>Model, View, View-Model (MVVM) - Windows Phone 7 Development for People in a Hurry</title>


    <script src="js/highlight/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    

    <link rel="stylesheet" href="style.css" type="text/css" media="screen" charset="utf-8">
    <link rel="stylesheet" href="js/highlight/styles/github.css" type="text/css">

    <style type="text/css">
    
    </style>

  </head>
  <body>
    <ul id="nav">
        <li><a href="/index.html">Home</a></li>
        <li><a href="index.html">Windows Phone 7 Development for People in a Hurry</a></li>
    </ul>

    <div id="mainbody">

    <h1>Model, View, View-Model (MVVM) - Windows Phone 7 Development for People in a Hurry</h1>

    <h2>Introduction</h2>

    <ul>
      <li>MVVM stands for Model, View, View-Model</li>
      <li>It is a 'pattern' i.e. a coding convention that is not enforced but has benefits if you follow it</li>
      <li>You should follow this convention unless you have a good reason not to</li>
      <li>The MVVM pattern tells you how to split up and organise you code for your application</li>
      <li>It defines three roles for your code, the Model, the View and the View-Model
        <ul>
          <li><em>View</em> code deals with the user interface (UI)</li>
          <li><em>Model</em> code stores the application data</li>
          <li><em>View-Model</em> code interfaces the View code with the Model code</li>
        </ul>
      </li>
      <li>The MVVM pattern works well in Windows Phone because of 'data binding'</li>
    </ul>

    <h2>Data binding</h2>

    <ul>
        <li>To save writing lots of code to read and write data to and from the View (UI), the View can 'data bind' most XAML attributes to a property of a 'bound' object</li>
        <li>This is when changes in the 'bound' object are automatically reflected in the View and optionally vice-versa</li>
        <li>The bound object is the View-Model object</li>
        <li>This structure allows all updates to and from the Model to be made on the View-Model object - the View automatically updates accordingly</li>
    </ul>

    <div class="figure">
        <img src="images/binding_figure.png" width="522px" height="390px" />
    </div>


    <h2>Code organisation</h2>

      <p>We usually create a directory in our project for each of these roles. Files are organised into these directories depending on their role</p>

    <h3>View</h3>

    <ul>
      <li>Pages and UserControls (i.e. custom widgets) defined in XAML and their 'code behind files' (i.e. the .cs or .vb files that are linked to the .xaml file in the Visual Studio project explorer) belong in the view</li>
      <li>In the code-behind files we generally put only code to handle UI behaviour (e.g. showing a MessageBox or handling a button click)</li>
      <li>If a button click does something that is not to do with the UI, for example save an object to a database, then the code-behind should immediately call a method on the View-Model</li>
    </ul>

    <h3>Model</h3>

    <ul>
        <li>Code that provides the interface for the data source (e.g. database, XML files, webserver etc.) belongs in the model.</li>
        <li>The classes that contain the data from the datasource e.g.  the 'Customer' class and the 'Invoice' class belong in the Model</li>
        <li>However, collections of these classes, for example to be displayed in a list in the View, should be defined in the View-Model</li>
        <li>Also the actual calling of the interface to the datasource should be done in the View-Model</li>
    </ul>

    <h3>View-Model</h3>

    <ul>
        <li>The object that provides the properties for UI binding <em>is</em> the View-Model</li>
        <li>Methods that takes the raw data from the Model and processes it for the UI goes in the View-Model class</li>
        <li>Methods that process submitted user input to be saved to the Model goes in the View-Model class</li>
        <li>Smaller applications usually have one View-Model class for the entire application, larger applications may split so that there is one View-Model class for every XAML page</li>
    </ul>

    <h3>Other code</h3>

    <ul>
        <li>Other code which does not easily fall into one of the three categories such as e.g. code for processing speech, can be put in a separate directory</li>
    </ul>

    <h3>Further notes</h3>

    <ul>
        <li>It should be possible to remove the View code from the project and the application should still compile and run (albeit with no way to input or output data)</li>
        <li>The Model and the View-Model however are tightly related and cannot operate without each other</li>
    </ul>

    <h2>Benefits of MVVM</h2>

    <ul>
        <li>Lots of the UI coding is taken care of</li>
        <li>Expression Blend has tools to mock up a fake View-Model object with sample data so you can design the UI without a working backend</li>
        <li>A de-coupled View makes substituting another View e.g. web, desktop more straightforward</li>
        <li>Unit testing of the backend is easier, since it does not have to load the UI for it to compile and run</li>
        <li>However, with only the free development tools, writing the getters/setters plus appropriate events all bound View-Model properties to get it to work is tedious</li>
    </ul>


    <h2>Implementing binding</h2>

    <p>First we must establish a DataContext. In the code-behind constructor in C#,</p>

    <pre><code>this.DataContext = myViewModel;</code></pre>

    <p><code>this</code> refers to the page object. This means that property names specified in binding in page elements will refer to the <code>myViewModel</code> properties.</p>

    <h3>Basic binding</h3>

    <pre><code>
        &lt;TextBlock Text="{Binding Name}" /&gt;
    </code></pre>

    <p>means that the <code>Text</code> attribute of the <code>TextBlock</code> is bound to the <code>Name</code> property on the ViewModel instance.</p>

    <h3>Two-way binding</h3>

    <pre><code>
        &lt;TextBox Text="{Binding Name, Mode=TwoWay}" /&gt;
    </code></pre>

    <p>is similar but now the UI can write to the ViewModel property as well as read from it.</p>

    <h3>Binding via a Convertor</h3>

    <p>Some attributes require UI specific values. For example the Visibility attribute requires the bound data type to be a Visibility enum which is specific to XAML. Writing a View-Model property of type Visibility is therefore tied to XAML code and therfore more difficult to adapt to HTML for example. This is solved with Converters. These are classes that live in the Converter.cs file in the View folder that intercept the code between the bound property and the XAML attribute.</p>
    <p>In the <code>phone:PhoneApplicationPage.Resources</code> element,</p>

    <pre><code>&lt;My_ViewNamespace:BoolToStrings x:Key="BoolToVisibilityConverter"/&gt;</code></pre>

    <p>then the actual binding,</p>

    <pre><code>
&lt;Canvas Visibility="{Binding IsProtected, Convertor=BoolToVisibilityConverter}" /&gt;
    </code></pre>

    <p>This passes the value of the IsProtected property through the BoolToVisibilityConverter class before showing in the UI. Converter classes implement the <code>IValueConverter</code> interface like below,</p>

    <pre><code>public class BoolToVisibilityConverter : System.Windows.Data.IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo cultureInfo)
    {
        if ((bool)value)
        {
            return Visibility.Visible;
        }
        else
        {
            return Visibility.Collapsed;
        }
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo cultureInfo)
    {
       return (Visibility)value == Visibility.Visible;
    }
}
    </code></pre>

    </div>


  </body>
</html>
