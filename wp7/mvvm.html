<!DOCTYPE html>
<html>
  <head>
    <title>Model, View, View-Model (MVVM) - Windows Phone Development for People in a Hurry</title>


    <script src="js/highlight/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    

    <link rel="stylesheet" href="styles/style.css" type="text/css" media="screen" charset="utf-8">
    <link rel="stylesheet" href="js/highlight/styles/github.css" type="text/css">

    <style type="text/css">
    
    </style>

  </head>
  <body>
    <ul id="nav">
        <li><a href="index.html">Home</a></li>
    </ul>

    <div id="mainbody">

    <h2 id="tagline">Windows Phone Development for People in a Hurry</h2>

    <h1>Model, View, View-Model (MVVM)</h1>

    <h2>Introduction</h2>

    <ul>
      <li>MVVM stands for Model, View, View-Model</li>
      <li>It is just a <a href="glossary.html#pattern">pattern</a>, however you should follow it unless you have a good reason not to</li>
      <li>It organises your code into three roles for your code, the Model, the View and the View-Model
        <ul class="compact">
          <li>View code deals with the user interface (UI)</li>
          <li>Model code stores the application data</li>
          <li>View-Model code is (usually) a single object interfaces the View code with the Model code</li>
        </ul>
      </li>
      <li>The MVVM pattern works well in Windows Phone because of 'Data Binding'</li>
    </ul>

    <h2>Data binding</h2>

    <ul>
        <li>To save writing lots of code to read and write data to and from the View (UI), the View can 'databind' most XAML attributes to a 'bound' property of an object.</li>
        <li>When the 'bound' property changes, this is automatically reflected in the View and (optionally) vice-versa</li>
        <li>We write the View-Model object to be the bound object</li>
        <li>This structure allows most application logic to be concerned with making changes on the View-Model object in C#/VB - the View automatically updates accordingly</li>
        <li>For details on how this is implemented, see <a href="binding.html">Data binding for people in a hurry</a></li>
    </ul>

    <div class="figure">
        <img src="images/binding_figure.png" width="522px" height="390px" />
    </div>

    <h2>Benefits of MVVM</h2>

    <ul>
        <li>Lots of the UI coding is taken care of</li>
        <li>Expression Blend has tools to mock up a fake View-Model object with sample data so you can design the UI without a working backend</li>
        <li>A de-coupled View makes substituting another View (e.g. web, desktop) more straightforward</li>
        <li>Unit testing of the backend is easier, since it does not have to load the UI for it to compile and run</li>
        <li>However, with only the free development tools, writing the getters/setters plus appropriate events all bound View-Model properties to get it to work is tedious</li>
    </ul>


    <h2>Implementing MVVM</h2>

      <p>The <a href="skeleton.html">skeleton project</a> contains a directory for each of these roles. Files are organised into these directories depending on their role</p>

    <h3>View</h3>

    <ul>
      <li>Pages and UserControls (i.e. custom widgets) defined in XAML and their 'code behind files' (i.e. the .cs or .vb files that are linked to the .xaml file in the Visual Studio project explorer) belong in the View</li>
      <li>In the code-behind files we generally put only code to handle UI behaviour (e.g. showing a MessageBox or handling a button click)</li>
      <li>If a button click does something that is not to do with the UI, for example save an object to a database, then the code-behind should immediately call a method on the View-Model</li>
    </ul>

    <h3>Model</h3>

    <ul>
        <li>Code that implements the interface for the data source (e.g. database, XML files, webservice etc.) belongs in the Model.</li>
        <li>However the actual calling of the interface should be done in the View-Model</li>
        <li>The classes that contain the data from the datasource e.g.  the 'Customer' class and the 'Invoice' class belong in the Model</li>
        <li>However, collections of these classes, for example to be displayed in a list in the View, should be in the View-Model</li>
    </ul>

    <h3>View-Model</h3>

    <ul>
        <li>The object that provides the properties for UI binding is the View-Model</li>
        <li>Methods that takes the raw data from the Model and processes it for the UI goes in the View-Model class</li>
        <li>Methods that process submitted user input to be saved to the Model goes in the View-Model class</li>
        <li>Smaller applications usually have one View-Model class for the entire application, larger applications may split so that there is one View-Model class for every XAML page</li>
    </ul>

    <h3>Other code</h3>

    <ul>
        <li>Other code which does not easily fall into one of the three categories such as e.g. code for processing speech, can be put in a separate directory</li>
    </ul>

    <h3>Further notes</h3>

    <ul>
        <li>Create a public property 'VM' for the View-Model in the App.xaml.cs code-behind. This can be instantiated in the contructor. Now you can access the same View-Model instance anywhere in the app using <code>App.VM</code></li>
        <li>Write the View-Model so that slow operations do not all occur at the same time when the app is loading e.g. if your app reads a lot of data from a database, only load enough to display the loading page</li> 
        <li>It should be possible to remove the View code folder from the project and the application should still compile and run (albeit with no way to input or output data)</li>
        <li>The Model and the View-Model however are tightly related and cannot operate without each other</li>
    </ul>



    </div>


  </body>
</html>
